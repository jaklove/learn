1、Redis持久化机制
   Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。
实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，
然后子进程退出内存释放。(bgsave) 写时复制技术：
  RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件

  AOF：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容
当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。

2.缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题
  缓存雪崩: 我们可以简单的理解为：由于原有缓存失效，新缓存未到期间。
  (例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力,
  严重的会造成数据库宕机,从而形成一系列连锁反应，造成整个系统崩溃。
  解决办法：大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，
  从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。

  缓存穿透：
     缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去
数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。
    解决办法: 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉,
从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），
我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设存，这样第二次到缓冲中获取就有值了，而不会
继续访问数据库，这种办法最简单粗暴。

  缓存击穿:
      缓存击穿，就是某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。
  解决这个问题有如下办法:
      1.可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力
      2.使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新
      3.针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效


  5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？
对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。
  缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空

  布隆过滤器（推荐）
  Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同，
为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们
该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。

  缓存预热
    缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，
先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！
   解决思路：
      1.直接写个缓存刷新页面，上线时手工操作下；
      2.数据量不大，可以在项目启动的时候自动进行加载；
      3.定时刷新缓存；
      4.缓存更新

   除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：
   (1).定时去清理过期的缓存；
   (2).当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。
   两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡


  缓存降级:
    当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，
仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。
降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。
   以参考日志级别设置预案：
     1.一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
     2.警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
     3.错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
     4.严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。
        因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。

Memcache与Redis的区别都有哪些？
  1、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据
  2、数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储
  3、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数
       的话，会浪费一定的时间去移动和请求。
  4、value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。
  5.redis的速度比memcached快很多
  6.Redis支持数据的备份，即master-slave模式的数据备份。

单线程的redis为什么这么快？
  1、纯内存操作
  2.单线程操作，避免了频繁的上下文切换
  3.采用了非阻塞I/O多路复用机制

redis的数据类型，以及每种数据类型的使用场景
  1.这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存
  2.这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构
    存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
  3、使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，
     性能极佳，用户体验好.本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。
  4.set,就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
  5.sorted set 热点排名


redis的过期策略以及内存淘汰机制
  redis采用的是定期删除+惰性删除策略
  为什么不用定时删除策略?
    定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.
    定期删除+惰性删除是如何工作的呢?
       定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，
而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除

采用定期删除+惰性删除就没其他问题了么?
  不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。
在redis.conf中有一行配置:maxmemory-policy volatile-lru

该配置就是配内存淘汰策略:
 volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
 no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错
ps:如果没有设置 expire 的key, 不满足先决条件(prerequisites);那么 volatile-lru, volatile-random 和volatile-ttl 策略的行为和 noeviction(不删除) 基本上一致。

Redis 为什么是单线程的?
   因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽.既然单线程容易实现，而且CPU不会成为瓶颈，
那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问.
1、绝大部分请求是纯粹的内存操作（非常快速）
2、采用单线程,避免了不必要的上下文切换和竞争条件
3、非阻塞IO优点：
   （1）速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
   （2）支持丰富数据类型，支持string，list，set，sorted set，hash
    (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
    (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题

Redis 常见性能问题和解决方案？
   1、Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
   2.如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
   3.为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
   4.尽量避免在压力很大的主库上增加从库
   5.主从复制不要用图状结构，用单向链表结构更为稳定，即： Master <- Slave1 <- Slave2 <-Slave3…


为什么Redis的操作是原子性的，怎么保证原子性的？
  对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。
Redis的操作之所以是原子性的，是因为Redis是单线程的。
  Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。
  多个命令在并发中也是原子性的吗？
  不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua==的方式实现.

Redis事务?
  Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的
  Redis会将一个事务中的所有命令序列化，然后按顺序执行。
  1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
  2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行；
  3.如果在一个事务中出现运行错误，那么正确的命令会被执行。
     （1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，
         而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
     （2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。
     （3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
     （4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。


redis底层数据结构
  简单来说就是Redis对key-value封装成对象，key是一个对象，value也是一个对象。每个对象都有type(类型)、encoding(编码)、ptr(指向底层数据结构的指针)来表示。

2.1 SDS简单动态字符串
   简单动态字符串(Simple dynamic string,SDS),
  Redis使用sdshdr结构来表示一个SDS值：
   struct sdshdr{
       // 字节数组，用于保存字符串
       char buf[];
       // 记录buf数组中已使用的字节数量，也是字符串的长度
       int len;
       // 记录buf数组未使用的字节数量
       int free;
   }
   使用使用SDS的好处的好处：
    1.sdshdr数据结构中用len属性记录了字符串的长度。那么获取字符串的长度时，时间复杂度只需要O(1)
    2.SDS不会发生溢出的问题，如果修改SDS时，空间不足。先会扩展空间，再进行修改！(内部实现了动态扩展机制)。
    3.SDS可以减少内存分配的次数(空间预分配机制)。在扩展空间时，除了分配修改时所必要的空间，还会分配额外的空闲空间(free 属性)。
    4.SDS是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据


2.2 链表
   Redis中的链表是怎么实现的：
   typedef strcut listNode{
       //前置节点
       strcut listNode  *pre;
       //后置节点
       strcut listNode  *pre;
       //节点的值
       void  *value;
   }listNode

   使用listNode是可以组成链表了，Redis中使用list结构来持有链表：
   typedef struct list{

       //表头结点
       listNode  *head;

       //表尾节点
       listNode  *tail;

       //链表长度
       unsigned long len;

       //节点值复制函数
       void *(*dup) (viod *ptr);

       //节点值释放函数
       void  (*free) (viod *ptr);

       //节点值对比函数
       int (*match) (void *ptr,void *key);

   }list

 Redis链表的特性:
 1.无环双向链表
 2.获取表头指针，表尾指针，链表节点长度的时间复杂度均为O(1)
 3.链表使用void *指针来保存节点值，可以保存各种不同类型的值

2.3 哈希表
  在Redis中，key-value的数据结构底层就是哈希表来实现的。
在Redis里边，哈希表使用dictht结构来定义：
      typedef struct dictht{

          //哈希表数组
          dictEntry **table;

          //哈希表大小
          unsigned long size;

          //哈希表大小掩码，用于计算索引值
          //总是等于size-1
          unsigned long sizemark;

          //哈希表已有节点数量
          unsigned long used;

      }dictht

      redis的hash表结构

2.4跳跃表(shiplist)
  跳跃表(shiplist)是实现sortset(有序集合)的底层数据结构之一！

redis的高级用法：
  Bitmap: 位图是支持按 bit 位来存储信息，可以用来实现布隆过滤器（BloomFilter）；

  HyperLogLog:供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；

  Geospatial:可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？

  pub/sub：功能是订阅发布功能，可以用作简单的消息队列。

  Pipeline：可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。

  Lua：Redis 支持提交 Lua 脚本来执行一系列的功能。




Redis将AOF重写程序放到子进程里执行(BGREWRITEAOF命令)，像BGSAVE命令一样fork出一个子进程来完成重写AOF的操作，从而不会影响到主进程，
AOF后台重写是不会阻塞主进程接收请求的，新的写命令请求可能会导致当前数据库和重写后的AOF文件的数据不一致！，
为了解决数据不一致的问题，Redis服务器设置了一个AOF重写缓冲区，这个缓存区会在服务器创建出子进程之后使用。当子进程重写aof后，子进程会发送
信号让父进程的重写缓冲区数据写到新的aof文件中，新的aof文件覆盖旧的aof文件

RDB持久化对过期键的策略：
  1.执行SAVE或者BGSAVE命令创建出的RDB文件，程序会对数据库中的过期键检查，已过期的键不会保存在RDB文件中。
  2.载入RDB文件时，程序同样会对RDB文件中的键进行检查，过期的键会被忽略。

RDB和AOF用哪个？
   RDB和AOF并不互斥，它俩可以同时使用。
   1.RDB的优点：载入时恢复数据快、文件体积小。
   2.RDB的缺点:会一定程度上丢失数据(因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。)
   3.AOF的优点：丢失数据少(默认配置只丢失一秒的数据)。
   4.AOF的缺点：恢复数据相对较慢，文件体积大

   如果Redis服务器同时开启了RDB和AOF持久化，服务器会优先使用AOF文件来还原数据(因为AOF更新频率比RDB更新频率要高，还原的数据更完善)

Redis开发了自己的网络事件处理器，这个处理器被称为文件事件处理器。
     文件事件处理器由四部分组成：socket、io多路复用程序、文件事件分派器、命令请求处理器
 文件事件处理器使用I/O多路复用程序来同时监听多个Socket。当被监听的Socket准备好执行连接应答(accept)、读取(read)等等操作时，
与操作相对应的文件事件就会产生，根据文件事件来为Socket关联对应的事件处理器，从而实现功能。要值得注意的是：
Redis中的I/O多路复用程序会将所有产生事件的Socket放到一个队列里边，然后通过这个队列以有序、同步、每次一个Socket的方式向文件事件分派器传送套接字。
也就是说：当上一个Socket处理完毕后，I/O多路复用程序才会向文件事件分派器传送下一个Socket。


Redis架构
   主从架构的好处:
     1.读写分离(主服务器负责写，从服务器负责读)
     2.高可用(某一台从服务器挂了，其他从服务器还能继续接收请求，不影响服务)
     3.处理更多的并发量(每台从服务器都可以接收读请求，读QPS就上去了)

   复制功能分为两个操作：
     同步(sync):将从服务器的数据库状态更新至主服务器的数据库状态
     命令传播(command propagate): 主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致,让主从服务器的数据库状态重新回到一致状态。

完整重同步:
    1.从服务器向主服务器发送PSYNC命令
    2.收到PSYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件。并用一个缓冲区来记录从现在开始执行的所有写命令。
    3.当主服务器的BGSAVE命令执行完后，将生成的RDB文件发送给从服务器，从服务器接收和载入RBD文件。将自己的数据库状态更新至与主服务器执行BGSAVE命令时的状态。
    4.主服务器将所有缓冲区的写命令发送给从服务器，从服务器执行这些写命令，达到数据最终一致性。

部分重同步:
    接下来我们来看看部分重同步，部分重同步可以让我们断线后重连只需要同步缺失的数据:
    部分重同步功能由以下部分组成：
      1.主从服务器的复制偏移量
      2.主服务器的复制积压缓冲区
      3.服务器运行的ID(run ID)

 复制偏移量：执行复制的双方都会分别维护一个复制偏移量:
   1.主服务器每次传播N个字节，就将自己的复制偏移量加上N
   2.从服务器每次收到主服务器的N个字节，就将自己的复制偏移量加上N

通过对比主从复制的偏移量，就很容易知道主从服务器的数据是否处于一致性的状态！
那断线重连以后，从服务器向主服务器发送PSYNC命令，报告现在的偏移量是36，那么主服务器该对从服务器执行完整重同步还是部分重同步呢？
这就交由复制积压缓冲区来决定:
  当主服务器进行命令传播时，不仅仅会将写命令发送给所有的从服务器，还会将写命令入队到复制积压缓冲区里面(这个大小可以调的)。
如果复制积压缓冲区存在丢失的偏移量的数据，那就执行部分重同步，否则执行完整重同步。服务器运行的ID(run ID)实际上就是用来比对ID是否相同。
如果不相同，则说明从服务器断线之前复制的主服务器和当前连接的主服务器是两台服务器，这就会进行完整重同步。

   当完成了同步之后，主从服务器就会进入命令传播阶段。这时主服务器只要将自己的写命令发送给从服务器，
而从服务器接收并执行主服务器发送过来的写命令，就可以保证主从服务器一直保持数据一致了


Redis哨兵模式集群：
   该模式是从Redis的2.6版本开始提供的，但是当时这个版本的模式是不稳定的，直到Redis的2.8版本以后，这个哨兵模式才稳定下来，
在生产环境中，如果想要使用Redis的哨兵模式，也会尽量使用Redis的2.8版本之后的版本。无论是主从模式，还是哨兵模式，这两个模式
都有一个问题，不能水平扩容，并且这两个模式的高可用特性都会受到Master主节点内存的限制。
还有一点，实现哨兵模式的配置也不简单，甚至可以说有些繁琐，所以在工业场景里这两个模式都不建议使用。

  Sentinel(哨兵)进程是用于监控redis集群中Master主服务器工作的状态，在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，
保证系统的高可用，其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来

 每个哨兵(Sentinel)进程会向其它哨兵(Sentinel)、Master、Slave定时发送消息，以确认对方是否”活”着，
 如果发现对方在指定配置时间(可配置的)内未得到回应，则暂时认为对方已掉线，也就是所谓的”主观认为宕机”。
当“哨兵群”中的多数Sentinel进程在对Master主服务器做出 SDOWN 的判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master Server下线判断
这种方式就是“客观宕机”，从剩下的slave从服务器节点中，选一台提升为Master服务器节点，然后自动修改相关配置，并开启故障转移（failover）。

  哨兵(sentinel) 虽然有一个单独的可执行文件 redis-sentinel ,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 --sentinel 选项来启动哨兵(sentinel)，哨兵(sentinel) 的一些设计思路和zookeeper非常类似。

1、Sentinel（哨兵）进程的作用：
  (1).监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。
  (2).提醒(Notification)：当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。
  (3).自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,它会将失效Master的其中一个Slave升级为新的Master,
  并让失效Master的其他Slave改为复制新的Master,当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master.
  Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。

2、Sentinel（哨兵）进程的工作方式：
   1】、每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
   2】、如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，
       则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。
   3】、如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认
       Master主服务器的确进入了主观下线状态。
   4】、当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN），
       则Master主服务器会被标记为客观下线（ODOWN）。
   5】、在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。
   6】、当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
   7】、若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线,Master主服务器的客观下线状态就会被移除。
       若Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

3、哨兵模式的环境：
   1】、Master主服务器配置信息：IP:192.168.127.128, Port:6379，OS:Linux
   2】、Slave从服务器的配置信息：IP:192.168.127.129 Port:6379，OS:Linux
   3】、在Slave从服务器上安装了一个哨兵进程（Sentinel），在Master服务器也安装了一个哨兵进程（Sentinel）。

①INFO
    sentinel的基本状态信息

②SENTINEL masters
    列出所有被监视的主服务器，以及这些主服务器的当前状态

③SENTINEL slaves
    列出给定主服务器的所有从服务器，以及这些从服务器的当前状态

④SENTINEL get-master-addr-by-name
    返回给定名字的主服务器的 IP 地址和端口号

哨兵模式的优缺点：
  优点：
     1、哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。
     2、主从可以切换，故障可以转移，系统可用性更好。
     3、哨兵模式是主从模式的升级，系统更健壮，可用性更高。
 　缺点:
    1、Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。

    在选举哨兵领导者时，我们可以制定这样一个选举规则：
      1.每个哨兵都询问其它哨兵，请求对方为自己投票
      2.每个哨兵只投票给第一个请求投票的哨兵，且只能投票一次
      3.首先拿到超过半数投票的哨兵，当选为领导者，发起主从切换
    其实，这个选举的过程就是我们经常听到的：分布式系统领域中的「共识算法」。

 这个算法还规定节点的数量必须是奇数个，这样可以保证系统中即使有节点发生了故障，剩余超过「半数」的节点状态正常，依旧可以提供正确的结果，也就是说，这个算法还兼容了存在故障节点的情况。
共识算法在分布式系统领域有很多，例如 Paxos、Raft，哨兵选举领导者这个场景，使用的是 Raft 共识算法，因为它足够简单，且易于实现。

我们一起来分析一下：
 1.稳定性：Redis 故障宕机，我们有哨兵 + 副本，可以自动完成主从切换
 2.读性能：读请求量增长，我们可以再部署多个 slave，读写分离，分担读压力
 3.写性能：写请求量增长，但我们只有一个 master 实例，这个实例达到瓶颈怎么办？

我们制定规则如下：
 1.每个节点各自存储一部分数据，所有节点数据之和才是全量数据
 2.制定一个路由规则，对于不同的 key，把它路由到固定一个实例上进行读写


而分片集群根据路由规则所在位置的不同，还可以分为两大类：
 1.客户端分片
 2.服务端分片

当你使用 Redis Cluster 时，你的业务应用需要使用配套的 Redis SDK，这个 SDK 内就集成好了路由规则，不需要你自己编写了

再来看服务端分片:
   这种方案指的是，路由规则不放在客户端来做，而是在客户端和服务端之间增加一个「中间代理层」，这个代理就是我们经常听到的 Proxy。
   而数据的路由规则，就放在这个 Proxy 层来维护。

   这样一来，你就无需关心服务端有多少个 Redis 节点了，只需要和这个 Proxy 交互即可。Proxy 会把你的请求根据路由规则，转发到对应的 Redis 节点上，
而且，当集群实例不足以支撑更大的流量请求时，还可以横向扩容，添加新的 Redis 实例提升性能，这一切对于你的客户端来说，都是透明无感知的。

业界开源的 Redis 分片集群方案，例如 Twemproxy、Codis 就是采用的这种方案。

1.为什么要实现Redis Cluster?
   1.主从复制不能实现高可用
   2.随着公司发展，用户数量增多，并发越来越多，业务需要更高的QPS，而主从复制中单机的QPS可能无法满足业务需求
   3.数据量的考虑，现有服务器内存不能满足业务数据的需要时，单纯向服务器添加内存不能达到要求，此时需要考虑分布式需求，把数据分布到不同服务器上
   4.网络流量需求：业务的流量已经超过服务器的网卡的上限值，可以考虑使用分布式来进行分流
   5.离线计算，需要中间环节缓冲等别的需求

2.2 常用数据分布方式之顺序分布
   比如：1到100个数字，要保存在3个节点上，按照顺序分区，把数据平均分配三个节点上
   1号到33号数据保存到节点1上，34号到66号数据保存到节点2上，67号到100号数据保存到节点3上

2.3 常用数据分布方式之哈希分布
   例如1到100个数字，对每个数字进行哈希运算，然后对每个数的哈希结果除以节点数进行取余，
余数为1则保存在第1个节点上，余数为2则保存在第2个节点上，余数为0则保存在第3个节点，这样可以保证数据被打散，同时保证数据分布的比较均匀

哈希分布方式分为三个分区方式：
   1.节点取余分区
     比如有100个数据，对每个数据进行hash运算之后，与节点数进行取余运算，根据余数不同保存在不同的节点上

节点取余方式是非常简单的一种分区方式
   节点取余分区方式有一个问题：即当增加或减少节点时，原来节点中的80%的数据会进行迁移操作，对所有数据重新进行分布

节点取余方式优点：
    客户端分片
    配置简单：对数据进行哈希，然后取余
节点取余方式缺点：
    数据节点伸缩时，导致数据迁移
    迁移数量和添加节点数据有关，建议翻倍扩容

2.3.2 一致性哈希分区
一致性哈希原理：将所有的数据当做一个token环，token环中的数据范围是0到2的32次方。然后为每一个数据节点分配一个token范围值，这个节点就负责保存这个范围内的数据。

对每一个key进行hash运算，被哈希后的结果在哪个token的范围内，则按顺时针去找最近的节点，这个key将会被保存在这个节点上。

一致性hash扩容：
  4个key被hash之后的值在在n1节点和n2节点之间，按照顺时针规则，这4个key都会被保存在n2节点上，
 如果在n1节点和n2节点之间添加n5节点，当下次有key被hash之后的值在n1节点和n5节点之间，这些key就会被保存在n5节点上面了
 在上面的例子里，添加n5节点之后，数据迁移会在n1节点和n2节点之间进行，n3节点和n4节点不受影响，数据迁移范围被缩小很多

  同理，如果有1000个节点，此时添加一个节点，受影响的节点范围最多只有千分之2
一致性哈希一般用在节点比较多的时候

一致性哈希分区优点：
   采用客户端分片方式：哈希 + 顺时针(优化取余)
   节点伸缩时，只影响邻近节点，但是还是有数据迁移

一致性哈希分区缺点：
   翻倍伸缩，保证最小迁移数据和负载均衡

虚拟槽分区?
  虚拟槽分区是Redis Cluster采用的分区方式
预设虚拟槽，每个槽就相当于一个数字，有一定范围。每个槽映射一个数据子集，一般比节点数大,Redis Cluster中预设虚拟槽的范围为0到16383

步骤:
   1.把16384槽按照节点数量进行平均分配，由节点进行管理。
   2.对每个key按照CRC16规则进行hash运算。
   3.把hash结果对16383进行取余
   4.把余数发送给Redis节点
   5.节点接收到数据，验证是否在自己管理的槽编号的范围?
         (1)如果在自己管理的槽编号范围内，则把数据保存到数据槽中，然后返回执行结果
         (2)如果在自己管理的槽编号范围外，则会把数据发送给正确的节点，由正确的节点来把数据保存在对应的槽中

需要注意的是：Redis Cluster的节点之间会共享消息，每个节点都会知道是哪个节点负责哪个范围内的数据槽

虚拟槽分布方式中，由于每个节点管理一部分数据槽，数据保存到数据槽中。当节点扩容或者缩容时，对数据槽进行重新分配迁移即可，数据不会丢失。
虚拟槽分区特点：
   1.使用服务端管理节点，槽，数据：例如Redis Cluster
   2.可以对数据打散，又可以保证数据分布均匀


3.Redis Cluster基本架构
3.1节点 Redis Cluster是分布式架构：即Redis Cluster中有多个节点，每个节点都负责进行数据读写操作
  每个节点之间会进行通信。

3.2 meet操作

3.3 分配槽
  把16384个槽平均分配给节点进行管理，每个节点只能对自己负责的槽进行读写操作，
由于每个节点之间都彼此通信，每个节点都知道另外节点负责管理的槽范围。

  客户端访问任意节点时，对数据key按照CRC16规则进行hash运算，然后对运算结果对16383进行取作，如果余数在当前访问的节点管理的槽范围内，则直接返回对应的数据
如果不在当前节点负责管理的槽范围内，则会告诉客户端去哪个节点获取数据，由客户端去正确的节点获取数据

3.4 复制
   保证高可用，每个主节点都有一个从节点，当主节点故障，Cluster会按照规则实现主备的高可用性
   对于节点来说，有一个配置项：cluster-enabled，即是否以集群模式启动

3.5 客户端路由
   1.每个节点通过通信都会共享Redis Cluster中槽和集群中对应节点的关系
   2.客户端向Redis Cluster的任意节点发送命令，接收命令的节点会根据CRC16规则进行hash运算与16383取余，计算自己的槽和对应节点
   3.如果保存数据的槽被分配给当前节点，则去槽中执行命令，并把命令执行结果返回给客户端.
   4.如果保存数据的槽不在当前节点的管理范围内，则向客户端返回moved重定向异常
   5.客户端接收到节点返回的结果，如果是moved异常，则从moved异常中获取目标节点的信息
   6.客户端向目标节点发送命令，获取命令执行结果

3.5.2 ask重定向
  在对集群进行扩容和缩容时，需要对槽及槽中数据进行迁移
当客户端向某个节点发送命令，节点向客户端返回moved异常，告诉客户端数据对应的槽的节点信息
如果此时正在进行集群扩展或者缩空操作，当客户端向正确的节点发送命令时，槽及槽中数据已经被迁移到别的节点了，就会返回ask，这就是ask重定向机制

步骤：
   1.客户端向目标节点发送命令，目标节点中的槽已经迁移支别的节点上了，此时目标节点会返回ask转向给客户端
   2.客户端向新的节点发送Asking命令给新的节点，然后再次向新节点发送命令
   3.新节点执行命令，把命令执行结果返回给客户端

moved异常与ask异常的相同点和不同点？
  1.两者都是客户端重定向
  2.moved异常：槽已经确定迁移，即槽已经不在当前节点
  3.ask异常：槽还在迁移中





