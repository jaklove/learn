一、基础篇
   1.1 TCP/IP ⽹络模型
    应⽤层:最上层的，也是我们能直接接触到的就是应⽤层（Application Layer），我们电脑或⼿机使⽤的应⽤软件都是在应 ⽤层实现

    传输层：应⽤层的数据包会传给传输层，传输层（Transport Layer）是为应⽤层提供⽹络⽀持的。
在在传输层会有两个传输协议，分别是 TCP 和 UDP，⼤部分应⽤使⽤的正是 TCP 传输层协议，⽐如 HTTP 应⽤层协议。
TCP 相⽐ UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等这些都是为了保证数据包能可靠地传输给对⽅。
    UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对⽅，但它实时性相对更好，传输效率
也⾼。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应⽤层上实现就可以，不过要实现⼀个商⽤的可靠 UDP
传输协议，也不是⼀件简单的事情。
    端口： 当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数
据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是端⼝。

    ⽹络层: 传输层可能⼤家刚接触的时候，会认为它负责将数据从⼀个设备传输到另⼀个设备，事实上它并不负责。
实际场景中的⽹络环节是错综复杂的，中间有各种各样的线路和分叉路⼝，如果⼀个设备的数据要传输给另⼀个设
备，就需要在各种各样的路径和节点进⾏选择，⽽传输层的设计理念是简单、⾼效、专注，如果传输层还负责这⼀
块功能就有点违背设计原则了, ⽽实际的传输功能就交给下⼀层，也就是⽹络层.
    ⽹络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装
成 IP 报⽂，如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚，得到⼀个即将发送到⽹络的 IP 报⽂
    我们⼀般⽤ IP 地址给设备进⾏编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段，每段是 8 位。只有⼀个单纯
的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道⼀个⼀个去匹配？这显然
不科学。
   因此，需要将 IP 地址分成两种意义：
    1.⼀个是⽹络号，负责标识该 IP 地址是属于哪个⼦⽹的；
    2.⼀个是主机号，负责标识同⼀⼦⽹下的不同主机；

怎么分的呢？这需要配合⼦⽹掩码才能算出 IP 地址 的⽹络号和主机号。那么在寻址的过程中，先匹配到相同的⽹络号，才会去找对应的主机.
    除了寻址能⼒， IP 协议还有另⼀个᯿要的能⼒就是路由。实际场景中，两台设备并不是⽤⼀条⽹线连接起来的，
 ⽽是通过很多⽹关、路由器、交换机等众多⽹络设备连接起来的，那么就会形成很多条⽹络的路径，因此当数据包
 到达⼀个⽹络节点，就需要通过算法决定下⼀步⾛哪条路径。因此，IP 协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路
 径。寻址更像在导航，路由更像在操作⽅向盘。

   数据链路层
   ⼀旦数据需要跨⽹络传输，就需要有⼀个设备同时在两个⽹络当中，这个设备⼀般是路由器，路由器可以通过路由
表计算出下⼀个要去的 IP 地址。那问题来了，路由器怎么知道这个 IP 地址是哪个设备的呢？
于是，就需要有⼀个专⻔的层来标识⽹络中的设备,让数据在⼀个链路中传输，这就是数据链路层（Data LinkLayer），
它主要为⽹络层提供链路级别传输的服务。每⼀台设备的⽹卡都会有⼀个 MAC 地址,它就是⽤来唯⼀标识设备的。
。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址,这样就知道这个 IP 地址是哪个设备的了。

   物理层：
     当数据准备要从设备发送到⽹络时，需要把数据包转换成电信号让其可以在物理介质中传输，这⼀层就是物理层
（Physical Layer），它主要是为数据链路层提供⼆进制传输的服务。
   总结：综上所述，⽹络协议通常是由上到下，分成 5 层没，分别是应⽤层，传输层，⽹络层，数据链路层和物理层。


HTTP
   HTTP 基本概念：
     1.HTTP 是超⽂本传输协议，也就是HyperText Transfer Protocol。

   能否详细解释「超⽂本传输协议」？
     HTTP的名字「超⽂本协议传输」，它可以拆成三个部分：超⽂本、传输、协议
针对 HTTP 协议，我们可以这么理解。HTTP 是⼀个⽤在计算机世界⾥的协议。它使⽤计算机能够理解的语⾔确⽴了⼀种计算机之间交流通信的规范
(两个以上的参与者），以及相关的各种控制和错误处理⽅式（⾏为约定和规范）。
     所谓的「传输」，很好理解，就是把⼀堆东⻄从 A 点搬到 B 点，或者从 B 点 搬到 A 点,
HTTP 协议是⼀个双向协议。
    针对传输，我们可以进⼀步理解了 HTTP。 HTTP 是⼀个在计算机世界⾥专⻔⽤来在两点之间传输数据的约定和规范。
     「超⽂本」：我们先来理解「⽂本」，在互联⽹早期的时候只是简单的字符⽂字，但现在「⽂本」的涵义已经可以扩展为图⽚、
视频、压缩包等，在 HTTP 眼⾥这些都算作「⽂本」。再来理解「超⽂本」，它就是超越了普通⽂本的⽂本，它是⽂字、图⽚、视频等的混合体，最关键有超链接，能从
⼀个超⽂本跳转到另外⼀个超⽂本。
     最终版本：HTTP 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。

     2.那「HTTP 是⽤于从互联⽹服务器传输超⽂本到本地浏览器的协议 ，这种说法正确吗？
       这种说法是不正确的。因为也可以是「服务器< -- >服务器」，所以采⽤两点之间的描述会更准确。


  Http状态码
     1xx: 1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。
     2xx: 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态
          「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。
          「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据
          「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态

     3xx:  3xx 类状态码表示客户端请求的资源发送了变动 ,需要客户端⽤新的 URL ᯿新发送请求获取资源，也就是重定向
          「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。
          「302 Found」表示临时᯿定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。
           301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。
          「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，⽤于缓存控制。
     4xx:  4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。
           「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。
            [403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错
            [404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。

     5xx:   类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。
           「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。
           「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思
           「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务发⽣了错误
           「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后᯿试”的意思

   HTTP 常⻅字段有哪些？
       Host 字段:  客户端发送请求时，⽤来指定服务器的域名。

       Content-Length 字段:  服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。
                             Content-Length: 1000(如上⾯则是告诉浏览器，本次服务器回应的数据⻓度是 1000 个字节，后⾯的字节就属于下⼀个回应了)

       Connection 字段:      Connection 字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤
                             HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为Keep-Alive
                             ⼀个可以复⽤的 TCP 连接就建⽴了，直到客户端或服务器主动关闭连接。但是，这不是标准字段

       Content-Type字段:     Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。
                             Content-Type: text/html; charset=utf-8(上⾯的类型表明，发送的是⽹⻚，⽽且编码是UTF-8)

       Accept: */* 字段: 客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式，上⾯代码中，客户端声明⾃⼰可以接受任何格式的数据

       Content-Encoding 字段：Content-Encoding 字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式
                              Content-Encoding: gzip(上⾯表示服务器返回的数据采⽤了 gzip ⽅式压缩，告知客户端需要⽤此⽅式解压。)

       Accept-Encoding字段： 客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法（Accept-Encoding: gzip, deflate）

   GET 与 POST区别：
       1. Get ⽅法的含义是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。
       2.POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥

   GET 和 POST ⽅法都是安全和幂等的吗？
       先说明下安全和幂等的概念：
         1.在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。
         2.所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。
         那么很明显 GET ⽅法就是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全
           的，且每次的结果都是相同的。

         POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多
         个资源，所以不是幂等的。

   HTTP 特性
     1.你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？
         HTTP 最凸出的优点是「简单、灵活和易于扩展、应⽤⼴泛和跨平台」
         1. 简单HTTP 基本的报⽂格式就是 header + body，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习和使⽤的⻔槛
         2. 灵活和易于扩展
            HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充
            同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化，HTTPS 也就是在 HTTP 与 TCP 层之间增加了
            SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基于 UDP 的QUIC。
         3. 应⽤⼴泛和跨平台
            互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、刷贴吧到购
            物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。

         4.HTTP 协议⾥有优缺点⼀体的双刃剑，分别是「⽆状态、明⽂传输」，同时还有⼀⼤缺点「不安全」。
           1. ⽆状态双刃剑：⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的
                     负担，能够把更多的 CPU 和内存⽤来对外提供服务
             ⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。
           2. 明⽂传输双刃剑
           3. 不安全
             1.通信使⽤明⽂（不加密），内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。
             2.不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了
             3.⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。

    HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极致

    那你再说下 HTTP/1.1 的性能如何？
        HTTP 协议是基于 TCP/IP，并且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点⾥
     1. ⻓连接:早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是
        串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销,为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，
        也叫持久连接。这种⽅式的好处在于减少了 TCP 连接的᯿复建⽴和断开所造成的额外开销，减轻了服务器端的负载,
        持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。

     2. 管道⽹络传输
        HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。
        即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。
        (举例来说，客户端需要请求两个资源。以前的做法是，在同⼀个TCP连接⾥⾯，先发送 A 请求，然后等待服务器做
        出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。),但是服务器还是按照顺序，先回应 A 请求，
        完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求排队等着。这称为「队头堵塞」。

     3. 队头阻塞
       「请求 - 应答」的模式加剧了 HTTP 的性能问题
       因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致
       客户端⼀直请求不到数据，这也就是「队头阻塞」。好⽐上班的路上塞⻋。
       总之 HTTP/1.1 的性能⼀般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能

     HTTP 与 HTTPS的区别：
        1. HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在
        TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。
        2. HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之
        后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。
        3.HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。
        4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

     HTTPS 解决了 HTTP 的哪些问题？
        1.窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没
        2.篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。
        3.冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。

     HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了上述的⻛险：
       1.信息加密：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没
       2.校验机制：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴告。
       3.身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。

     HTTPS 是如何解决上⾯的三个⻛险的？
       1.混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。
       2.摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了
         篡改的⻛险
       3.将服务器公钥放⼊到数字证书中，解决了冒充的⻛险。

      1. 混合加密
         通过混合加密的⽅式可以保证信息的机密性，解决了窃听的⻛险。

        对称加密就是，a用锁锁住文件，发给b，然后a再发钥匙给b，b拿到锁和钥匙，解锁文件
        非对称加密是，a要像b发文件，b把自己的锁发给a，a锁好后给b，b的钥匙一直在自己手上，用自己的钥匙(私钥)解自己的锁(公钥)，这样就不用担心钥匙在传递过程中被窃取。

       HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式
        1.在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。
        2.在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。

        采⽤「混合加密」的⽅式的原因：
        1.对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换
        2.⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。

        2. 摘要算法:
            摘要算法⽤来实现完整性，能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险.
            客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发
            送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出
            的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。

        3. 数字证书
           客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。
           这就存在些问题，如何保证公钥不被篡改和信任度？
           所以这⾥就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证
           机构颁发）中，只要证书是可信的，公钥就是可信的。

           大致流程： 1.服务器把自己的公钥注册到CA
                      2.CA用自己的私钥将服务器的公钥数字签名并颁发数字证书
                      3.客户端拿到服务器的数字证书后，使用CA证书的公钥确认服务器的数字证书的真实性(服务器的公钥+CA的数字签名)
                      4.从数字证书获取服务器后的公钥使用它对报文进行加密发送
                      5.通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险


       HTTPS 是如何建⽴连接的？其间交互了什么？
          SSL/TLS 协议基本流程：1.客户端向服务器索要并验证服务器的公钥。
                                2.双⽅协商⽣产「会话秘钥」。
                                3.双⽅采⽤「会话秘钥」进⾏加密
                                4.前两步也就是 SSL/TLS 的建⽴过程，也就是握⼿阶段。


       SSL/TLS 协议建⽴的详细流程：
         1. ClientHello:
            ⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求
            在这⼀步，客户端主要向服务器发送以下信息
             （1）客户端⽀持的 SSL/TLS 协议版本，如 TLS 1.2 版本。
             （2）客户端⽣产的随机数（ Client Random ），后⾯⽤于⽣产「会话秘钥」
             （3）客户端⽀持的密码套件列表，如 RSA 加密算法

         2. SeverHello
            服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：
            （1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。
            （2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥
            （3）确认的密码套件列表，如 RSA 加密算法
            （4）服务器的数字证书。

         3.客户端回应
            客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。
            如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如下信息：
            （1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。
            （2）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。
            （3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘
            要，⽤来供服务端校验。上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就⽤双⽅协
             商的加密算法，各⾃⽣成本次通信的「会话秘钥」。

         4. 服务器的最后回应
            服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发⽣最后的信息：
            （1）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信
            （2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供客户端校验。
            ⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP
            协议，只不过⽤「会话秘钥」加密内容。


HTTP/1.1、HTTP/2、HTTP/3 演变
   说说 HTTP/1.1 相⽐ HTTP/1.0 提⾼了什么性能？

HTTP/1.1 相⽐ HTTP/1.0 性能上的改进：
  1.使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。
  2.⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。

但 HTTP/1.1 还是有性能瓶颈：
  1.请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分
  2.发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；
  3.服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；
  4.没有请求优先级控制；
  5.请求只能从客户端开始，服务器只能被动响应。

那 HTTP/2 相⽐ HTTP/1.1 性能上的改进：
    1.头部压缩
     HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分
这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不
发送同样字段了，只发送索引号，这样就提⾼速度了。

    2.⼆进制格式
     HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并
且统称为帧（frame）：头信息帧和数据帧。
    这样虽然对⼈不友好，但是对计算机⾮常友好，因为计算机只懂⼆进制，那么收到报⽂后，⽆需再将明⽂的报⽂转
成⼆进制，⽽是直接解析⼆进制报⽂，这增加了数据传输的效率。

    3.数据流
     HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据
包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规
定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。

    4.多路复⽤
     HTTP/2 是可以在⼀个连接中并发多个请求或回应⽽不⽤按照顺序⼀⼀对应
移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼了连接的利⽤率
举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就回应 A 请求
已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。

    5.服务器推送
     HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发
送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减
少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。

   (1)HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了
   (2)HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求


⼀起来看看 HTTP/2 ⽜逼在哪？
   1.延迟难以下降，虽然现在⽹络的「带宽」相⽐以前变多了，但是延迟降到⼀定幅度后，就很难再下降了，说⽩
      了就是到达了延迟的下限；
   2.并发连接有限，⾕歌浏览器最⼤并发连接数是 6 个，⽽且每⼀个连接都要经过 TCP 和 TLS 握⼿耗时，以及
      TCP 慢启动过程给流ᰁ带来的影响；
   3.队头阻塞问题，同⼀连接只能在完成⼀个 HTTP 事务（请求和响应）后，才能处理下⼀个事务；
   4.HTTP 头部巨⼤且᯿复，由于 HTTP 协议是⽆状态的，每⼀个请求都得携带 HTTP 头部，特别是对于有携带
     cookie 的头部，⽽ cookie 的⼤⼩通常很⼤；
   5.不⽀持服务器推送消息，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这⽆疑浪费⼤ᰁ了
   带宽和服务器资源。

为了解决 HTTP/1.1 性能问题，具体的优化⼿段你可以看这篇⽂章「」，这⾥我举例⼏个常⻅的优化⼿段：
   1.将多张⼩图合并成⼀张⼤图供浏览器 JavaScript 来切割使⽤，这样可以将多个请求合并成⼀个请求，但是带来
     了新的问题，当某张⼩图⽚更新了，那么需要᯿新请求⼤图⽚，浪费了⼤ᰁ的⽹络带宽；
   2.将图⽚的⼆进制数据通过 base64 编码后，把编码数据嵌⼊到 HTML 或 CSS ⽂件中，以此来减少⽹络请求次
     数；
   3.将多个体积较⼩的 JavaScript ⽂件使⽤ webpack 等⼯具打包成⼀个体积更⼤的 JavaScript ⽂件，以⼀个请求
     替代了很多个请求，但是带来的问题，当某个 js ⽂件变化了，需要᯿新请求同⼀个包⾥的所有 js ⽂件；
   4.将同⼀个⻚⾯的资源分散到不同域名，提升并发连接上限，因为浏览器通常对同⼀域名的 HTTP 连接最⼤只能
     是 6 个；


兼容 HTTP/1.1?
    HTTP/2 出来的⽬的是为了改善 HTTP 的性能。协议升级有⼀个很᯿要的地⽅，就是要兼容⽼版本的协议，否则新
协议推⼴起来就相当困难，所幸 HTTP/2 做到了兼容 HTTP/1.1
   第⼀点，HTTP/2 没有在 URI ⾥引⼊新的协议名，仍然⽤「http://」表示明⽂协议，⽤「https://」表示加密协议，
   于是只需要浏览器和服务器在背后⾃动升级协议，这样可以让⽤户意识不到协议的升级，很好的实现了协议的平滑
   升级。
   第⼆点，只在应⽤层做了改变，还是基于 TCP 协议传输，应⽤层⽅⾯为了保持功能上的兼容，HTTP/2 把 HTTP 分
   解成了「语义」和「语法」两个部分，「语义」层不做改动，与 HTTP/1.1 完全⼀致，⽐如请求⽅法、状态码、头
   字段等规则保留不变。

但是，HTTP/2 在「语法」层⾯做了很多改造，基本改变了 HTTP 报⽂的传输格式。

  头部压缩
  HTTP 协议的报⽂是由「Header + Body」构成的，对于 Body 部分，HTTP/1.1 协议可以使⽤头字段 「ContentEncoding」指定 Body 的压缩⽅式，
  ⽐如⽤ gzip 压缩，这样可以节约带宽，但报⽂中的另外⼀部分 Header，是没有针对它的优化⼿段

HTTP/1.1 报⽂中 Header 部分存在的问题:
   1.含很多固定的字段，⽐如Cookie、User Agent、Accept 等，这些字段加起来也⾼达⼏百字节甚⾄上千字节，
     所以有必要压缩；
   2.⼤ᰁ的请求和响应的报⽂⾥有很多字段值都是᯿复的，这样会使得⼤ᰁ带宽被这些冗余的数据占⽤了，所以有
     必须要避免重复性；
   3.字段是 ASCII 编码的，虽然易于⼈类观察，但效率低，所以有必要改成⼆进制编码；

HTTP/2 对 Header 部分做了⼤改造，把以上的问题都解决了。
   HTTP/2 没使⽤常⻅的 gzip 压缩⽅式来压缩头部，⽽是开发了 HPACK 算法，HPACK 算法主要包含三个组成部分：
   1.静态字典；
   2.动态字典；
   3.Huffman 编码（压缩算法）；
   客户端和服务器两端都会建⽴和维护「字典」，⽤⻓度较⼩的索引号表示重复复的字符串，再⽤ Huffman 编码压缩
数据，可达到 50%~90% 的⾼压缩率。


⼆进制帧？
   HTTP/2 厉害的地⽅在于将 HTTP/1 的⽂本格式改成⼆进制格式传输数据，极⼤提⾼了 HTTP 传输效率，⽽且⼆进
   制数据使⽤位运算能⾼效解析。

并发传输？
    ⽽ HTTP/2 就很⽜逼了，通过 Stream 这个设计，多个 Stream 复⽤⼀条 TCP 连接，达到并发的效果，解决了
HTTP/1.1 队头阻塞的问题，提⾼了 HTTP 传输的吞吐ᰁ。

服务器主动推送资源？
   HTTP/1.1 不⽀持服务器主动推送资源给客户端，都是由客户端向服务器发起请求后，才能获取到服务器响应的资
源。

那HTTP/2 的推送是怎么实现的？
  客户端发起的请求，必须使⽤的是奇数号 Stream，服务器主动的推送，使⽤的是偶数号 Stream。服务器在推送资
源时，会通过 PUSH_PROMISE 帧传输 HTTP 头部，并通过帧中的 Promised Stream ID 字段告知客户端，接下来
会在哪个偶数号 Stream 中发送包体。

    HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，
这样内核才会将缓冲区⾥的数据返回给 HTTP 应⽤，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只
能存放在内核缓冲区⾥，只有等到这 1 个字节数据到达时，HTTP/2 应⽤层才能从内核中拿到数据，这就是
HTTP/2 队头阻塞问题。

  有没有什么解决⽅案呢？既然是 TCP 协议⾃身的问题，那⼲脆放弃 TCP 协议，转⽽使⽤ UDP 协议作为传输层协
议，这个⼤胆的决定， HTTP/3 协议做了！


TCP篇章
   TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。
     1.⾯向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀对多是⽆法做到的；
     2.可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端
     3.字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前
      ⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「᯿复」的
      报⽂会⾃动丢弃。

建⽴⼀个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识?
   1.Socket：由 IP 地址和端⼝号组成
   2.序列号：⽤来解决乱序问题等
   3.窗⼝⼤⼩：⽤来做流ᰁ控制

TCP 四元组可以唯⼀的确定⼀个连接四元组包括如下：
   1.源地址
   2.源端⼝
   3.⽬的地址
   4.⽬的端⼝

源地址和⽬的地址的字段（32位）是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机。
源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程。

最大tcp连接数 = 客户端ip数*客户端的端口数
   对 IPv4，客户端的 IP 数最多为 2 的 32 次⽅，客户端的端⼝数最多为 2 的 16 次⽅，也就是服务端单机最⼤TCP 连接数，约为 2 的 48 次⽅。

当然，服务端最⼤并发 TCP 连接数远不能达到理论上限
  1.⾸先主要是⽂件描述符限制，Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬；
  2.另⼀个是内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的。

UDP 和 TCP 有什么区别呢？分别的应⽤场景是？
  1.UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向「⽆连接」的通信服务。
  2.UDP 协议真的⾮常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：
     1.⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。
     2.包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。
     3.校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计。

TCP 和 UDP 区别：
   1. 连接
      (1).TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接
      (2).UDP 是不需要连接，即刻传输数据
   2.服务对象
      (1).TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。
      (2).UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信
   3.可靠性
      (1).TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不᯿复、按需到达
      (2).UDP 是尽最⼤努⼒交付，不保证可靠交付数据
   4.拥塞控制、流ᰁ控制
      (1).TCP 有拥塞控制和流ᰁ控制机制，保证数据传输的安全性
      (2).UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。
   5.⾸部开销
      (1).TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」字段则会变⻓的。
      (2).UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。

   6. 传输⽅式
      (1).TCP 是流式传输，没有边界，但保证顺序和可靠
      (2).UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。

   7.分片不同：
      (1).TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP
          数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚
      (2).UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要᯿传所有的数据包，这样传输
          效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。

TCP 和 UDP 应⽤场景：
     1.由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于：
       (1)FTP ⽂件传输
       (2)HTTP / HTTPS

由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于：
(1)包总ᰁ较少的通信，如 DNS 、 SNMP 等
(2.视频、⾳频等多媒体通信)
(3).⼴播通信

为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢？
     原因是 TCP 有可变⻓的「选项」字段，⽽ UDP 头部⻓度则是不会变化的，⽆需多⼀个字段去记录 UDP 的⾸部⻓度

TCP 连接建⽴?
  TCP 三次握⼿过程和状态变迁
    ⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态

    (1).客户端会随机初始化序号(client_isn)，将此序号置于 TCP ⾸部的「序号」字段中,同时把 SYN 标志位置为1,
    表示SYN报⽂。接着把第⼀个 SYN 报⽂发送给服务端，表示向服务端发起连接，该报⽂不包含应⽤层数据，之后客户端处于 SYN-SENT 状态。

    (2).服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号（ server_isn ），将此序号填⼊），将此序号填⼊
     TCP ⾸部的「序号」字段中,其次把 TCP ⾸部的「确认应答号」字段填⼊ client_isn + 1 ,接着把 SYN 和ACK 标志位置为 1 。
     最后把该报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于 SYN-RCVD 状态。

    (3).客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂，⾸先该应答报⽂ TCP ⾸部 ACK 标志位置为
        1 ，其次「确认应答号」字段填⼊ server_isn + 1 ，最后把报⽂发送给服务端，这次报⽂可以携带客户到
        服务器的数据，之后客户端处于 ESTABLISHED 状态

    (4).服务器收到客户端的应答报⽂后，也进⼊ ESTABLISHED 状态

从上⾯的过程可以发现第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的，这也是⾯试常问的题。⼀旦完成三次握⼿，
双⽅都处于 ESTABLISHED 状态，此时连接就已建⽴完成，客户端和服务端就可以相互发送数据了。


如何在 Linux 系统中查看 TCP 状态？
   TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。

为什么是三次握⼿？不是两次、四次？
   在前⾯我们知道了什么是 TCP 连接?
     1.⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝⼤⼩称为连接。

接下来以三个⽅⾯分析三次握⼿的原因：
    1.三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）
    2.三次握⼿才可以同步双⽅的初始序列号
    3.三次握⼿才可以避免资源浪费

原因⼀：避免历史连接
    三次握⼿的⾸要原因是为了防⽌旧的重复连接初始化造成混乱。

⽹络环境是错综复杂的，往往并不是如我们期望的⼀样，先发送的数据包，就先到达⽬标主机，反⽽它很骚，可能
会由于⽹络拥堵等乱七⼋糟的原因，会使得旧的数据包，先到达⽬标主机，那么这种情况下 TCP 三次握⼿是如何
避免的呢？
   客户端连续发送多次 SYN 建⽴连接的报⽂，在⽹络拥堵情况下：
    1.一个「旧 SYN 报⽂」⽐「最新的 SYN 」 报⽂早到达了服务端;
    2.那么此时服务端就会回⼀个 SYN + ACK 报⽂给客户端；
    3.客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送RST 报⽂给服务端，表示中⽌这⼀次连接。


   如果是两次握⼿连接，就不能判断当前连接是否是历史连接，三次握⼿则可以在客户端（发送⽅）准备发送第三次
报⽂时，客户端因有⾜够的上下⽂来判断当前连接是否是历史连接：
    1.如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中⽌历史连接；
    2.如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双⽅就会成功建⽴连接

所以，TCP 使⽤三次握⼿建⽴连接的最主要原因是防⽌历史连接初始化了连接。

原因⼆：同步双⽅初始序列号
   TCP 协议的通信双⽅， 都必须维护⼀个「序列号」， 序列号是可靠传输的⼀个关键因素，它的作⽤：
     1.接收⽅可以去除᯿复的数据；
     2.接收⽅可以根据数据包的序列号按序接收；
     3.可以标识发送出去的数据包中，哪些是已经被对⽅收到的；

可⻅，序列号在 TCP 连接中占据着⾮常᯿要的作⽤，所以当客户端发送携带「初始序列号」的 SYN 报⽂的时
候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收，那当服务端发送「初始序
列号」给客户端的时候，依然也要得到客户端的应答回应，这样⼀来⼀回，才能确保双⽅的初始序列号能被可靠的
同步。
   ⽽两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接收。

原因三：避免资源浪费
   即两次握⼿会造成消息滞留情况下，服务器重复接受⽆⽤的连接请求 SYN 报⽂，⽽造成᯿复分配资源。

    TCP 建⽴连接时，通过三次握⼿能防⽌历史连接的建⽴，能减少双⽅不必要的资源开销，能帮助双⽅同步初始化序列号。
序列号能够保证数据包不᯿复、不丢弃和按序传输。

不使⽤「两次握⼿」和「四次握⼿」的原因？
 1.「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；
 2.「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。

 为什么客户端和服务端的初始序列号 ISN 是不相同的？
  如果⼀个已经失效的连接被重复⽤了，但是该旧连接的历史报⽂还残留在⽹络中，如果序列号相同，那么就⽆法分辨
出该报⽂是不是历史报⽂，如果历史报⽂被新的连接接收了，则会产⽣数据错乱。
   所以，每次建⽴连接前᯿新初始化⼀个序列号主要是为了通信双⽅能够根据序号将不属于本连接的报⽂段丢弃，
另⼀⽅⾯是为了安全性，防⽌⿊客伪造的相同序列号的 TCP 报⽂被对⽅接收。

初始序列号 ISN 是如何随机产⽣的？
   起始 ISN 是基于时钟的，每 4 毫秒 + 1，转⼀圈要 4.55 个⼩时。

我们先来认识下 MTU 和 MSS
  1.MTU ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 字节；
  2.MSS ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度；

如果在 TCP 的整个报⽂（头部 + 数据）交给 IP 层进⾏分⽚，会有什么异常呢？
  当 IP 层有⼀个超过 MTU ⼤⼩的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进⾏分⽚，把数据分⽚成
  若⼲⽚，保证每⼀个分⽚都⼩于 MTU。把⼀份 IP 数据报进⾏分⽚以后，由⽬标主机的 IP 层来进⾏᯿新组装后，
  再交给上⼀层 TCP 传输层。

这看起来井然有序，但这存在隐患的，那么当如果⼀个 IP 分⽚丢失，整个 IP 报⽂的所有分⽚都得重传。
  因为 IP 层本身没有超时᯿传机制，它由传输层的 TCP 来负责超时和᯿传。

  当接收⽅发现 TCP 报⽂（头部 + 数据）的某⼀⽚丢失后，则不会响应 ACK 给对⽅，那么发送⽅的 TCP 在超时
后，就会᯿发「整个 TCP 报⽂（头部 + 数据）」。
因此，可以得知由 IP 层进⾏分⽚传输，是⾮常没有效率的。

   所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，当 TCP 层发现数据超过
MSS 时，则就先会进⾏分⽚，当然由它形成的 IP 包的⻓度也就不会⼤于 MTU ，⾃然也就不⽤ IP 分⽚了。
   经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后，进⾏重发时也是以 MSS 为单位，⽽不⽤᯿传所有的分⽚，⼤⼤
增加了᯿传的效率

TCP 连接断开?
   TCP 四次挥⼿过程和状态变迁,双⽅都可以主动断开连接，断开连接后主机中的「资源」将被释放。
   1.客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户端进⼊ FIN_WAIT_1 状态。
   2.服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。
   3.客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。
   4.等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。
   6.客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态
   7.服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。
   8.客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。

你可以看到，每个⽅向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为四次挥⼿。这⾥⼀点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态。

为什么挥⼿需要四次？
  再来回顾下四次挥⼿双⽅发 FIN 包的过程，就能理解为什么需要四次了。
  1.关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据.
  2.服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服
    务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。

从上⾯过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，
从⽽⽐三次握⼿导致多了⼀次

Socket 编程?
  1.服务端和客户端初始化 socket ，得到⽂件描述符；
  2.服务端调⽤ bind ，将绑定在 IP 地址和端⼝;
  3.服务端调⽤ listen ，进⾏监听；
  4.服务端调⽤ accept ，等待客户端连接;
  5.客户端调⽤ connect ，向服务器端的地址和端⼝发起连接请求；
  6.服务端 accept 返回⽤于传输的 socket 的⽂件描述符；
  7.客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据；
  8.客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完数
    据后，服务端调⽤ close ，表示连接关闭。

这⾥需要注意的是，服务端调⽤ accept 时，连接成功了会返回⼀个已完成连接的 socket，后续⽤来传输数据。
所以，监听的 socket 和真正⽤来传送数据的 socket，是「两个」 socket，⼀个叫作监听 socket，⼀个叫作已完成连接 socket。
成功连接建⽴之后，双⽅开始通过 read 和 write 函数来读写数据，就像往⼀个⽂件流⾥⾯写东⻄⼀样。

listen 时候参数 backlog 的意义？
   Linux内核中会维护两个队列：
   1.未完成连接队列（SYN 队列）：接收到⼀个 SYN 建⽴连接请求，处于 SYN_RCVD 状态；
   2.已完成连接队列（Accpet 队列）：已完成 TCP 三次握⼿过程，处于 ESTABLISHED 状态；

accept 发⽣在三次握⼿的哪⼀步？
   1.客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 client_isn，客户端进⼊
     SYN_SENT 状态；
   2.服务器端的协议栈收到这个包之后，和客户端进⾏ ACK 应答，应答的值为 client_isn+1，表示对 SYN 包
     client_isn 的确认，同时服务器也发送⼀个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务器端
     进⼊ SYN_RCVD 状态；
   3.客户端协议栈收到 ACK 之后，使得应⽤程序从 connect 调⽤返回，表示客户端到服务器端的单向连接建⽴
     成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进⾏应答，应答数据为
     server_isn+1；
   4.应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调⽤返回，这个时候服务器端到客户端的单向连接
     也建⽴成功，服务器端也进⼊ ESTABLISHED 状态。

   从上⾯的描述过程，我们可以得知客户端 connect 成功返回是在第⼆次握⼿，服务端 accept 成功返回是在三次握⼿成功之后。

客户端调⽤ close 了，连接是断开的流程是什么？
   1.客户端调⽤ close ，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报⽂，进⼊ FIN_WAIT_1状态；
   2.服务端接收到了 FIN 报⽂，TCP 协议栈会为 FIN 包插⼊⼀个⽂件结束符 EOF 到接收缓冲区中，应⽤程序可以
     通过 read 调⽤来感知这个 FIN 包。这个 EOF 会被放在已排队等候的其他已接收的数据之后，这就意味着服
     务端需要处理这种异常情况，因为 EOF 表示在该连接上再⽆额外数据到达。此时，服务端进⼊ CLOSE_WAIT
     状态；
   3.接着，当处理完数据后，⾃然就会读到 EOF ，于是也调⽤ close 关闭它的套接字，这会使得客户端会发出
     ⼀个 FIN 包，之后处于 LAST_ACK 状态；
   4.客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进⼊ TIME_WAIT 状态；
   5.服务端收到 ACK 确认包后，就进⼊了最后的 CLOSE 状态；
   6.客户端经过 2MSL 时间之后，也进⼊ CLOSE 状态


TCP 是通过序列号、确认应答、并发控制、连接管理以及窗⼝控制等机制实现可靠性传输的，今天，将重点介绍 TCP 的重传机制、滑动窗⼝、流量控制、拥塞控制。
 一、重传机制
    1.TCP 针对数据包丢失的情况，会⽤重传机制解决：
      (1).超时重传:重传机制的其中⼀个⽅式，就是在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对⽅的 ACK 确认应答报⽂，就会重发该数据，也就是我们常说的超时重传。
          其中TCP会存在以下2种情况发生超时重传：
           (1).数据包丢失
           (2).确认应答丢失

RTT 就是数据从⽹络⼀端传送到另⼀端所需的时间，也就是包的往返时间。实际上「报⽂往返 RTT 的值」是经常变化的，因为我们的⽹络也是时常变化的。也就因为「报⽂往返 RTT 的值」
是经常波动变化的，所以「超时᯿传时间 RTO 的值」应该是⼀个动态变化的值。

我们来看看 Linux 是如何计算 RTO 的呢?
估计往返时间，通常需要采样以下两个：
  1.需要 TCP 通过采样 RTT 的时间，然后进⾏加权平均，算出⼀个平滑 RTT 的值，⽽且这个值还是要不断变化的，因为⽹络状况不断地变化。
  2.除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有⼀个⼤的波动的话，很难被发现的情况

 二、快速重传
   TCP 还有另外⼀种快速重传（Fast Retransmit）机制，它不以时间为驱动，⽽是以数据驱动重传。
    快速重传传的⼯作⽅式是当收到三个相同的 ACK 报⽂时，会在定时器过期之前，᯿传丢失的报⽂段


 三、滑动窗⼝
    TCP 引⼊了窗⼝这个概念。即使在往返时间较⻓的情况下，它也不会降低⽹络通信的效率。
那么有了窗⼝，就可以指定窗⼝⼤⼩，窗⼝⼤⼩就是指⽆需等待确认应答，⽽可以继续发送数据的最⼤值。
(窗⼝的实现实际上是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已
 发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。)

窗⼝⼤⼩由哪⼀⽅决定？
  TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。
  这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来
发送数据，⽽不会导致接收端处理不过来。所以，通常窗⼝的⼤⼩是由接收⽅的窗⼝⼤⼩来决定的。
发送⽅发送的数据⼤⼩不能超过接收⽅的窗⼝⼤⼩，否则接收⽅就⽆法正常接收到数据。

发送⽅的滑动窗⼝?
  1.发送方的滑动窗口
     发送方的滑动窗口分成四个部分：中深蓝⾊⽅框是发送窗⼝，紫⾊⽅框是可⽤窗⼝
     #1 是已发送并收到 ACK确认的数据：1~31 字节
     #2 是已发送但未收到 ACK确认的数据：32~45 字节
     #3 是未发送但总⼤⼩在接收⽅处理范围内（接收⽅还有空间）：46~51字节
     #4 是未发送但总⼤⼩超过接收⽅处理范围（接收⽅没有空间）：52字节以后

  当发送⽅把数据「全部」都⼀下发送出去后，可⽤窗⼝的⼤⼩就为 0 了，表明可⽤窗⼝耗尽，在没收到
ACK 确认之前是⽆法继续发送数据了


ssl加密的过程中有ca证书
  数字签名的制作过程：
   1.CA机构拥有非对称加密的私钥和公钥。
   2.CA机构对证书明文数据T进行hash。
   3.对hash后的值用私钥加密，得到数字签名S。

   明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。

   浏览器验证过程：
   1.拿到证书，得到明文T，签名S。
   2.用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S。
   3.用证书里指明的hash算法对明文T进行hash得到T。
   4.显然通过以上步骤，T应当等于S，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。


中间人有可能篡改该证书吗？
  假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。
浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。
既然不可能篡改，那整个证书被掉包呢？

中间人有可能把证书掉包吗？
  假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，
然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？
其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。

为什么制作数字签名时需要hash一次？
  我初识HTTPS的时候就有这个疑问，因为似乎那里的hash有点多余，把hash过程去掉也能保证证书没有被篡改。
最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，
比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。

每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？
   服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，
服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！