一、基础篇
   1.1 TCP/IP ⽹络模型
    应⽤层:最上层的，也是我们能直接接触到的就是应⽤层（Application Layer），我们电脑或⼿机使⽤的应⽤软件都是在应 ⽤层实现

    传输层：应⽤层的数据包会传给传输层，传输层（Transport Layer）是为应⽤层提供⽹络⽀持的。
在在传输层会有两个传输协议，分别是 TCP 和 UDP，⼤部分应⽤使⽤的正是 TCP 传输层协议，⽐如 HTTP 应⽤层协议。
TCP 相⽐ UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等这些都是为了保证数据包能可靠地传输给对⽅。
    UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对⽅，但它实时性相对更好，传输效率
也⾼。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应⽤层上实现就可以，不过要实现⼀个商⽤的可靠 UDP
传输协议，也不是⼀件简单的事情。
    端口： 当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数
据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是端⼝。

    ⽹络层: 传输层可能⼤家刚接触的时候，会认为它负责将数据从⼀个设备传输到另⼀个设备，事实上它并不负责。
实际场景中的⽹络环节是错综复杂的，中间有各种各样的线路和分叉路⼝，如果⼀个设备的数据要传输给另⼀个设
备，就需要在各种各样的路径和节点进⾏选择，⽽传输层的设计理念是简单、⾼效、专注，如果传输层还负责这⼀
块功能就有点违背设计原则了, ⽽实际的传输功能就交给下⼀层，也就是⽹络层.
    ⽹络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装
成 IP 报⽂，如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚，得到⼀个即将发送到⽹络的 IP 报⽂
    我们⼀般⽤ IP 地址给设备进⾏编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段，每段是 8 位。只有⼀个单纯
的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道⼀个⼀个去匹配？这显然
不科学。
   因此，需要将 IP 地址分成两种意义：
    1.⼀个是⽹络号，负责标识该 IP 地址是属于哪个⼦⽹的；
    2.⼀个是主机号，负责标识同⼀⼦⽹下的不同主机；

怎么分的呢？这需要配合⼦⽹掩码才能算出 IP 地址 的⽹络号和主机号。那么在寻址的过程中，先匹配到相同的⽹络号，才会去找对应的主机.
    除了寻址能⼒， IP 协议还有另⼀个᯿要的能⼒就是路由。实际场景中，两台设备并不是⽤⼀条⽹线连接起来的，
 ⽽是通过很多⽹关、路由器、交换机等众多⽹络设备连接起来的，那么就会形成很多条⽹络的路径，因此当数据包
 到达⼀个⽹络节点，就需要通过算法决定下⼀步⾛哪条路径。因此，IP 协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路
 径。寻址更像在导航，路由更像在操作⽅向盘。

   数据链路层
   ⼀旦数据需要跨⽹络传输，就需要有⼀个设备同时在两个⽹络当中，这个设备⼀般是路由器，路由器可以通过路由
表计算出下⼀个要去的 IP 地址。那问题来了，路由器怎么知道这个 IP 地址是哪个设备的呢？
于是，就需要有⼀个专⻔的层来标识⽹络中的设备,让数据在⼀个链路中传输，这就是数据链路层（Data LinkLayer），
它主要为⽹络层提供链路级别传输的服务。每⼀台设备的⽹卡都会有⼀个 MAC 地址,它就是⽤来唯⼀标识设备的。
。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址,这样就知道这个 IP 地址是哪个设备的了。

   物理层：
     当数据准备要从设备发送到⽹络时，需要把数据包转换成电信号让其可以在物理介质中传输，这⼀层就是物理层
（Physical Layer），它主要是为数据链路层提供⼆进制传输的服务。
   总结：综上所述，⽹络协议通常是由上到下，分成 5 层没，分别是应⽤层，传输层，⽹络层，数据链路层和物理层。


HTTP
   HTTP 基本概念：
     1.HTTP 是超⽂本传输协议，也就是HyperText Transfer Protocol。

   能否详细解释「超⽂本传输协议」？
     HTTP的名字「超⽂本协议传输」，它可以拆成三个部分：超⽂本、传输、协议
针对 HTTP 协议，我们可以这么理解。HTTP 是⼀个⽤在计算机世界⾥的协议。它使⽤计算机能够理解的语⾔确⽴了⼀种计算机之间交流通信的规范
(两个以上的参与者），以及相关的各种控制和错误处理⽅式（⾏为约定和规范）。
     所谓的「传输」，很好理解，就是把⼀堆东⻄从 A 点搬到 B 点，或者从 B 点 搬到 A 点,
HTTP 协议是⼀个双向协议。
    针对传输，我们可以进⼀步理解了 HTTP。 HTTP 是⼀个在计算机世界⾥专⻔⽤来在两点之间传输数据的约定和规范。
     「超⽂本」：我们先来理解「⽂本」，在互联⽹早期的时候只是简单的字符⽂字，但现在「⽂本」的涵义已经可以扩展为图⽚、
视频、压缩包等，在 HTTP 眼⾥这些都算作「⽂本」。再来理解「超⽂本」，它就是超越了普通⽂本的⽂本，它是⽂字、图⽚、视频等的混合体，最关键有超链接，能从
⼀个超⽂本跳转到另外⼀个超⽂本。
     最终版本：HTTP 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。

     2.那「HTTP 是⽤于从互联⽹服务器传输超⽂本到本地浏览器的协议 ，这种说法正确吗？
       这种说法是不正确的。因为也可以是「服务器< -- >服务器」，所以采⽤两点之间的描述会更准确。


  Http状态码
     1xx: 1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。
     2xx: 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态
          「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。
          「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据
          「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态

     3xx:  3xx 类状态码表示客户端请求的资源发送了变动 ,需要客户端⽤新的 URL ᯿新发送请求获取资源，也就是重定向
          「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。
          「302 Found」表示临时᯿定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。
           301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。
          「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，⽤于缓存控制。
     4xx:  4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。
           「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。
            [403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错
            [404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。

     5xx:   类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。
           「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。
           「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思
           「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务发⽣了错误
           「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后᯿试”的意思

   HTTP 常⻅字段有哪些？
       Host 字段:  客户端发送请求时，⽤来指定服务器的域名。

       Content-Length 字段:  服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。
                             Content-Length: 1000(如上⾯则是告诉浏览器，本次服务器回应的数据⻓度是 1000 个字节，后⾯的字节就属于下⼀个回应了)

       Connection 字段:      Connection 字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤
                             HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为Keep-Alive
                             ⼀个可以复⽤的 TCP 连接就建⽴了，直到客户端或服务器主动关闭连接。但是，这不是标准字段

       Content-Type字段:     Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。
                             Content-Type: text/html; charset=utf-8(上⾯的类型表明，发送的是⽹⻚，⽽且编码是UTF-8)

       Accept: */* 字段: 客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式，上⾯代码中，客户端声明⾃⼰可以接受任何格式的数据

       Content-Encoding 字段：Content-Encoding 字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式
                              Content-Encoding: gzip(上⾯表示服务器返回的数据采⽤了 gzip ⽅式压缩，告知客户端需要⽤此⽅式解压。)

       Accept-Encoding字段： 客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法（Accept-Encoding: gzip, deflate）

   GET 与 POST区别：
       1. Get ⽅法的含义是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。
       2.POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥

   GET 和 POST ⽅法都是安全和幂等的吗？
       先说明下安全和幂等的概念：
         1.在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。
         2.所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。
         那么很明显 GET ⽅法就是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全
           的，且每次的结果都是相同的。

         POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多
         个资源，所以不是幂等的。

   HTTP 特性
     1.你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？
         HTTP 最凸出的优点是「简单、灵活和易于扩展、应⽤⼴泛和跨平台」
         1. 简单HTTP 基本的报⽂格式就是 header + body，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习和使⽤的⻔槛
         2. 灵活和易于扩展
            HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充
            同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化，HTTPS 也就是在 HTTP 与 TCP 层之间增加了
            SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基于 UDP 的QUIC。
         3. 应⽤⼴泛和跨平台
            互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、刷贴吧到购
            物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。

         4.HTTP 协议⾥有优缺点⼀体的双刃剑，分别是「⽆状态、明⽂传输」，同时还有⼀⼤缺点「不安全」。
           1. ⽆状态双刃剑：⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的
                     负担，能够把更多的 CPU 和内存⽤来对外提供服务
             ⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。
           2. 明⽂传输双刃剑
           3. 不安全
             1.通信使⽤明⽂（不加密），内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。
             2.不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了
             3.⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。

    HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极致

    那你再说下 HTTP/1.1 的性能如何？
        HTTP 协议是基于 TCP/IP，并且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点⾥
     1. ⻓连接:早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是
        串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销,为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，
        也叫持久连接。这种⽅式的好处在于减少了 TCP 连接的᯿复建⽴和断开所造成的额外开销，减轻了服务器端的负载,
        持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。

     2. 管道⽹络传输
        HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。
        即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。
        (举例来说，客户端需要请求两个资源。以前的做法是，在同⼀个TCP连接⾥⾯，先发送 A 请求，然后等待服务器做
        出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。),但是服务器还是按照顺序，先回应 A 请求，
        完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求排队等着。这称为「队头堵塞」。

     3. 队头阻塞
       「请求 - 应答」的模式加剧了 HTTP 的性能问题
       因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致
       客户端⼀直请求不到数据，这也就是「队头阻塞」。好⽐上班的路上塞⻋。
       总之 HTTP/1.1 的性能⼀般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能

     HTTP 与 HTTPS的区别：
        1. HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在
        TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。
        2. HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之
        后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。
        3.HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。
        4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

     HTTPS 解决了 HTTP 的哪些问题？
        1.窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没
        2.篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。
        3.冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。

     HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了上述的⻛险：
       1.信息加密：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没
       2.校验机制：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴告。
       3.身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。

     HTTPS 是如何解决上⾯的三个⻛险的？
       1.混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。
       2.摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了
         篡改的⻛险
       3.将服务器公钥放⼊到数字证书中，解决了冒充的⻛险。

      1. 混合加密
         通过混合加密的⽅式可以保证信息的机密性，解决了窃听的⻛险。

        对称加密就是，a用锁锁住文件，发给b，然后a再发钥匙给b，b拿到锁和钥匙，解锁文件
        非对称加密是，a要像b发文件，b把自己的锁发给a，a锁好后给b，b的钥匙一直在自己手上，用自己的钥匙(私钥)解自己的锁(公钥)，这样就不用担心钥匙在传递过程中被窃取。

       HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式
        1.在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。
        2.在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。

        采⽤「混合加密」的⽅式的原因：
        1.对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换
        2.⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。

        2. 摘要算法:
            摘要算法⽤来实现完整性，能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险.
            客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发
            送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出
            的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。

        3. 数字证书
           客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。
           这就存在些问题，如何保证公钥不被篡改和信任度？
           所以这⾥就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证
           机构颁发）中，只要证书是可信的，公钥就是可信的。

           大致流程： 1.服务器把自己的公钥注册到CA
                      2.CA用自己的私钥将服务器的公钥数字签名并颁发数字证书
                      3.客户端拿到服务器的数字证书后，使用CA证书的公钥确认服务器的数字证书的真实性(服务器的公钥+CA的数字签名)
                      4.从数字证书获取服务器后的公钥使用它对报文进行加密发送
                      5.通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险


       HTTPS 是如何建⽴连接的？其间交互了什么？
          SSL/TLS 协议基本流程：1.客户端向服务器索要并验证服务器的公钥。
                                2.双⽅协商⽣产「会话秘钥」。
                                3.双⽅采⽤「会话秘钥」进⾏加密
                                4.前两步也就是 SSL/TLS 的建⽴过程，也就是握⼿阶段。


       SSL/TLS 协议建⽴的详细流程：
         1. ClientHello:
            ⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求
            在这⼀步，客户端主要向服务器发送以下信息
             （1）客户端⽀持的 SSL/TLS 协议版本，如 TLS 1.2 版本。
             （2）客户端⽣产的随机数（ Client Random ），后⾯⽤于⽣产「会话秘钥」
             （3）客户端⽀持的密码套件列表，如 RSA 加密算法

         2. SeverHello
            服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：
            （1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。
            （2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥
            （3）确认的密码套件列表，如 RSA 加密算法
            （4）服务器的数字证书。

         3.客户端回应
            客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。
            如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如下信息：
            （1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。
            （2）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。
            （3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘
            要，⽤来供服务端校验。上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就⽤双⽅协
             商的加密算法，各⾃⽣成本次通信的「会话秘钥」。

         4. 服务器的最后回应
            服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发⽣最后的信息：
            （1）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信
            （2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供客户端校验。
            ⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP
            协议，只不过⽤「会话秘钥」加密内容。
